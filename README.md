# Project : Crusaders

 * 벨트스크롤 액션 게임을 만들어 보려고 합시다
 * 캐릭터 디자인까지 하기엔 시간이 너무 부족하다
 * ~~코딩 그만하고 캐릭터 그리고 싶다~~

## Features (Current)

### 조작계

 * 십자 방향키 : 이동
 * Z 키 : 근접공격
 * X 키 : 원거리 공격
 * * C 키 : 점프
 * Space : 특수(미구현)

#### 조작법

 * Z 키 연타 : 기본 근접 연속공격.
  * 기본근접공격1->기본근접공격2->기본근접공격3 으로 이행
  * FSM으로 순차적으로 이행하도록 통제
  * 기본근접공격 3의 경우 에어본 판정이 들어있음
 * X 키 연타 : 기본 원거리 연속공격.
  * 기본원거리공격1 -> 기본원거리공격2 순으로 이행
  * FSM으로 순차적으로 이행하도록 통제
  * 기본원거리공격2의 경우 에어본 판정이 들어있음
 * C 점프 중 Z 키 : 공중 근접공격
  * 일단 횟수제한은 없지만 점프 높이와 프레임 제한으로 공중에서 2회까지 발동가능 (강제로 1번만 하도록 조정할수도 있음)
  * 공격 판정은 플레이어에게 종속되어 움직인다
  * 점프중에 방향전환 불가능(이동방향 전환만 가능)

#### TODO

 * 방향키를 이용한 격겜 커맨드 만들기
 * 원거리 공격 구현
 * 점프 애니메이션 분리 : 점프 상승 -> 점프 하강으로 분리해야할듯
  * 에어본 애니메이션도 마찬가지

### 좌표계

 * 게임 내의 모든 오브젝트들은 다음의 좌표계를 따른다
  * 순수 고전 2D의 좌표계를 구현해보고 싶었다
 * 게임상의 좌표는 X,Y로 정의한다.
 * 오브젝트의 루트에서 관리됨
 * 맵상의 지형 충돌, 위치 판정을 전부 이거로 함
  * 캐릭터 루트 오브젝트와 맵 오브젝트(정적 콜라이더)와의 충돌을 통해 맵 통제를 구현한다.
   * Z축이 다른 맵을 어떻게 할지 (e.g. 낙사)가 좀 관건
   * 캐릭터 발이 지나갈때 Z값 확인을 하고 밀어낸다든가 해야할것같음
 * 가상의 Z축은 한단계 들어간 내부 오브젝트에서 관리
  * 충돌 판정할때와 공중 판정을 여기서 처리
  * 캐릭터 화면상의 좌표는 (X,Y+Z)로 정의된다.
 * 유니티의 Z축은 Z오더 배치용(Y가 낮으면 화면 앞쪽으로 온다)으로 사용한다

#### 충돌박스

 * 2단계 내부 오브젝트에 별도로 할당되어있음
 * 단 독립 오브젝트가 아닌 종속 오브젝트의 경우(대표적으로 근접공격판정)은 종속 오브젝트 루트를 별도로 두어 따로 관리함
 * 화면상의 (X,Y) 평면에 존재한다(가상 좌표계 상으로는 (X,Z)평면에 존재한다)
  * Y축 두께를 별도의 프로퍼티로 가진다.
 * 일단 화면상의(XY좌표계상의) 박스충돌 판정을 하고(유니티 기본 박스컬라이더 판정) 내부적으로 가상좌표계를 고려한 재계산을 수행
  * 가상 Z축을 고려한 내부 가상 체계를 만들어 박스 충돌 판정을 수행
 * 박스는 히트박스와 허트박스로 분리
  * 위의 요소들을 가진 부모 클래스를 상속받은 자식 클래스를 따로 정의하여 분리한다.
 * 허트박스와 히트박스는 다대다 충돌판정 관계를 갖는다
  * 허트박스가 히트박스를 인식한다
  * 프레임 다단히트를 방지하기 위해 충돌했던 히트박스를 기억하는 내부 구조를 가지고 있다.

##### 히트박스
 
 * 공격 오브젝트가 가지고 있는 충돌박스
 * 다음과 같은 프로퍼티들을 갖는다
  * 공격박스 유형(지속형/투사체)
   * 지속형은 허트박스와 피격하더라도 라이프타임동안 존속한다
   * 투사체 타입은 허트박스와 접촉시 판정 후 즉시 소멸한다.
  * 에어본 벡터
  * 넉백 수치(미구현)
   * 히트박스에 피격되면 일정거리 뒤로 밀려난다.
  * 강타 수치(미구현)
   * 강타 저항보다 높은 수치의 강타가 들어가면 와이어액션으로 날아간다(벽꽝)
  * 경직(미구현)
  * 역경직(미구현)
  * 근거리 데미지
  * 원거리 데미지

##### 허트박스

 * 피격당하는 오브젝트가 가지고 있는 충돌박스
 * 다음과 같은 프로퍼티들을 갖는다
  * 접촉했던 히트박스 오브젝트 목록
   * 앞서 말했듯이 다단히트 방지
   * 굳이 다단히트를 만들고 싶다면 공격 오브젝트를 여러개 생성한다
  * 근접 방어력
  * 원거리 방어력
  * 에어본 저항치
   * X축 힘에는 저항하지 않고 Y 축에만 저항한다.
   * 피격시 에어본 벡터의 Y축값을 절대치로 감소시키고 만약 피격시 계산된 에어본 벡터의 Y값이 0보다 작거나 같다면 뜨지 않는다.
  * 넉백 저항치(미구현)
  * 강타 저항치(미구현)
  * 히트리커버리(미구현)
  * 슈퍼아머수치(미구현)
   * 슈퍼아머수치가 양수일땐 피격 애니메이션이 재생되지 않는다

### 캐릭터

#### 애니메이션

 * Unity Animator을 이용하여 FSM 기반의 애니메이션 통제를 수행한다
  * *기본적으로 스테이트는 하나라고 가정하고 만들었으므로 스테이트가 여러개 공존할 수 있는 트랜지션 듀레이션에 유의*
  * ~~기본값으로 트랜지션 듀레이션이 설정되어있다 유니티 에니메이터 죽었으면~~
 * 플레이어 인풋(AI 캐릭터의 경우 AI의 행동방침 설정)과 외부 개입 요소들을 트리거나 불리언 플래그로 반영하여 애니메이션 트랜지션을 유도
  * 트리거의 경우 해당 트리거를 소비하는 트랜지션이 일어나기 전까지 소비되지 않으므로 필요할 때 적절하게 리셋해주는 과정이 필요하다
 * 애니메이션에서 통제되는 것
  * 공격판정 생성(애니메이션 이벤트로 호출된다)
  * 스프라이트 애니메이션(기본적으로는 루프기반)
  * 피격박스 형태
   * *상수형 스테이트이므로 변곡점에서의 탄젠트 통제에 유의(Constant로 설정한다)*
 * 사실상 가장 손이 많이 가는 부분 ~~디자인 제외~~

#### 오브젝트 구조

##### 루트 오브젝트

 * 월드상의 (X,Y) 좌표 통제
  * 지형경계와의 충돌판정
  * (X,Y)축에 관여된 모든 움직임
 * 인풋 처리
 * 캐릭터 스테이터스 저장
  * 체력
  * 스킬셋
  * 기타 자원
 * 발바닥 그림자를 넣을 예정(루트 위치가 잘 안보여서)
 * 자식은 게임 오브젝트(1단계 오브젝트) 하나만 둔다

##### 게임 오브젝트(1단계 오브젝트)

 * 좌우 방향 처리
  * localscale로 뒤집는다
 * Z축 처리
  * Z값 만큼 localposition을 Y축으로 옮긴다
  * 중력처리와 착지판정을 한다
 * 애니메이터
 * 스프라이트, 히트박스, 공격오브젝트 루트를 관리한다
  * 생성할 공격 오브젝트 리스트는 여기서 관리한다
 * 자식 오브젝트 목록
  * 공격 오브젝트 루트
  * 스프라이트 렌더러
  * 허트박스

###### 공격 오브젝트 루트

 * 플레이어에 종속되는 공격 오브젝트(주로 근접)들을 달아놓기 위한 루트 오브젝트
 * 별다른 기능은 없다
 * 특정 상황이 됐을때 모든 자식을 파괴하는 기능이 1단계 오브젝트에 내장되어 있으므로 여기선 별달리 할 게 없다(ZSync 기능을 넣어야할수 도 있음) * 

###### 스프라이트 렌더러

 * 캐릭터의 스프라이트를 그려주는 오브젝트
 * 애니메이터에서 통제하므로 역시 특별히 할 일은 없다

###### 허트박스

 * 피격박스
 * 마찬가지로 애니메이터에서 통제하므로 역시 특별히 할 일은 없다 

### 게임 진행 통제

 * 게임 진행이나 내부/외부 데이터를 통제하는 오브젝트/스크립트
 * 어느 단계까지 통제할 것인지에 따라서 나눔

#### CommonConfig

 * 가장 높은 단계의 통제 스크립트
 * 게임 외적인 단계까지 설정하는 스크립트
 * 게임 외부에 파일 형태로 읽고 쓰는 기능 포함
  * Json을 사용할 예정
 * ScriptableObject 형태로 싱글턴 패턴을 사용
 * 게임 전체에서 접근하는 데이터를 저장

##### CommonConfig에 저장되는 데이터

 * 사용가능한 캐릭터
  * 캐릭터 해금이 들어갈 예정
 * 사용 가능한 난이도
  * 특수 난이도는 해금식으로 사용
 * 그 외 자잘한 유저 데이터
  * 이름

#### GameCommon

 * 게임 내적으로 가장 높은 단계의 통제 스크립트
 * 게임 외부에 파일 형태로 읽고 쓰는 기능 포함
  * Json을 사용할 예정
 * ScriptableObject 형태로 싱글턴 패턴을 사용
 * 게임 인스턴스 내에서 사용할 데이터를 저장

##### GameCommon에 저장되는 데이터

 * 현재 설정된 난이도
 * 현재 선택한 캐릭터
 * 현재 캐릭터의 성장치
  * 경험치 / 혹은 레벨
 * 진행중인 스테이지
  * 스테이지 진행내역까지는 아니고 어느 스테이지를 진행중인지
 * 스테이지 진행에 따른 플래그들
  * 무슨 스테이지들을 깼는지
  * 선택지 내용 등

#### RuleManager

 * 씬 단위의 세부 규칙을 통제하는 스크립트
 * 씬 내에 Object로 존재
  * 공통 기능만 있고 세부적인건 씬별로 따로 만들어야 함
 * 정규화에 실패하여 개별적인 트리거호출구조는 상속받은 개별 클래스들에서 구현
  * 트리거 호출 메시지는 {TriggerObjectName}Triggered, 웨이브 종료 메시지는 {WaveName}Ended로 통일하여 각각 트리거, 웨이브 오브젝트에서 송출
  * e.g.) Wave1Ended, Trigger1Triggered

##### RuleManager이 하는 일

 * 진행 경로 통제
  * 지형지물 중에 플레이어의 진행을 가로막거나 하는 오브젝트들을 치워주거나 배치해서 스토리 진행을 시킴
  * 맵상에 배치한 트리거 오브젝트들을 통해서 진행상황 트리거 내역 확인
 * 적 웨이브 통제
  * 적 스포너들을 통제하여 적절하게 적들을 생성해냄
  * 적 웨이브를 섬멸했다면 진행경로 통제를 통해 플레이어를 다음 진행방향으로 유도
 * 스테이지(씬)진행 통제
  * 특정 트리거를 만족시켰다면(플레이어 죽음, 적 섬멸, 보스 토벌) 그에 따라서 스테이지 성공, 실패 등을 통제

#### WaveManager

 * 웨이브 단위로 통제하는 스크립트
 * 적 스포너들을 통제하여 적들을 불러오고 적들의 처리가 끝나면 끝남을 RuleManager에게 알림